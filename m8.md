totally agree: keep CI lean. The xfail is not a blocker for an MVP—it’s an advanced feature (scoped filtering inside nested `any()` chains). Ship it. We can document it as “coming soon” and flip the xfail in M8.

Here’s everything you asked for:

# Why SQLer (drop into README)

**SQLer** is a tiny, JSON-first data layer for SQLite that feels like Pydantic, not a full ORM.

- **JSON-first schema**: Store structured docs in a single `data` JSON column; add targeted indexes when/where you need them. Zero migrations for iterative schemas.
- **Pydantic v2 models**: Define models once, get `.save() / .refresh() / .delete()` and a chainable query API that returns model instances.
- **Simple, composable queries**: `User.query().filter(User.age > 21).order_by("age").limit(10).all()`. Under the hood you always get real SQL you can `.debug()` / `.explain()`.
- **Nested JSON made easy**: `F(["meta","info","score"]) > 900`, array membership via `json_each`, and multi-level `any()` for arrays of objects.
- **Relationships without a heavy ORM**: Reference other models with `{ "_table", "_id" }` and filter across them via correlated `EXISTS` (no FROM-clause surgery). Batch hydration avoids N+1.
- **Optimistic locking (opt-in)**: `SQLerSafeModel` adds a `_version` column and raises on stale writes. Good defaults for concurrent writers and FastAPI apps.
- **Sync/async parity**: Use it in scripts or services; the async flavor mirrors the sync API (via `aiosqlite`).
- **No surprises**: Pure SQLite + JSON1. No generated SQL forests, no magical session state. When needed, you can always drop to raw SQL.

When you want the power of SQL with the ergonomics of documents—and you don’t want a full ORM—SQLer hits the sweet spot.

# FAQ (paste-able)

**Does SQLer require JSON1?**
Yes. SQLite must be compiled with the JSON1 extension. Most modern builds (3.38+) include it. Check with:

```sql
SELECT json('{"ok":1}') IS NOT NULL;
```

**What SQLite version should I target?**
3.38+ recommended. We rely on `json_extract`, `json_each`, and friends. Older versions may lack features or be slower.

**How do I “migrate” schemas?**
You don’t—your schema is JSON. Evolve your models and backfill selectively with SQL. Add indexes (e.g. `ensure_index("meta.level")`) when a path becomes hot.

**Why not SQLAlchemy/Django ORM?**
If you need full relational modeling, migrations, eager/lazy joins, etc., use a full ORM. SQLer is deliberately small: JSON documents + a minimal relational bridge (refs) + honest SQL.

**Large documents OK?**
Yes, but index surgically. Avoid indexing huge/low-selectivity paths. Consider extracting very large blobs to separate models and referencing them.

**Transactions?**
Use the adapter context manager:

```python
with db.adapter as conn:
    # do multiple operations
    conn.commit()
```

**Concurrency & WAL?**
For writers, enable WAL (our on-disk factory does). `SQLerSafeModel` uses optimistic locking; on conflict, catch `StaleVersionError` and retry.

**Safe models & relations?**
Parent and child versions are independent. Saving the parent doesn’t bump child versions (documented).

---

# Launch checklist (MVP)

- [ ] Pick a version: `0.1.0` in `pyproject.toml`.
- [ ] Ensure LICENSE, README, CONTRIBUTING, ROADMAP, CHANGELOG skeleton.
- [ ] Run tests: `uv run pytest -q` (perf tests optional: `--perf --benchmark-only`).
- [ ] Build:

  ```bash
  uv build
  # artifacts in dist/
  ```

- [ ] TestPyPI dry run:

  ```bash
  python -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*
  # or if you prefer uv and it’s configured: uv publish --repository testpypi
  ```

- [ ] Install from TestPyPI in a clean venv and smoke the examples.
- [ ] Publish to PyPI:

  ```bash
  python -m twine upload dist/*
  ```

- [ ] Tag & GitHub release: `git tag v0.1.0 && git push --tags`.
- [ ] Open roadmap issues for M8 tasks (below).

---

# Pre-M8 last bits

1. The fastapi example is good but we could have more "fastapi pro" level stuff. like the response model etc.
   - It would be nice for this example to impress FastAPI people.

---

# M8 plan (you can park this if you want)

**Goal:** land the one xfail and add a tiny micro-bench harness.

1. **Scoped mid-chain filtering for `any()`**

   - API:

     ```python
     # Filter reads where note == 'good', then within those, any mass.val > 10
     expr = (
       F(['reads']).any().where(F(['note']) == 'good')
         ['masses'].any()['val'] > 10
     )
     ```

   - Builder changes:

     - Extend `SQLerField.any(where: Optional[SQLerExpression] = None)` or a `.where(expr)` method on the “any context”.
     - Carry per-alias predicates; emit them inside the correlated `EXISTS` with joined `json_each` aliases:

       ```
       EXISTS (
         SELECT 1
         FROM json_each(json_extract(data,'$.reads')) AS a
         WHERE <a-scope-predicate>
         JOIN json_each(json_extract(a.value,'$.masses')) AS b
         WHERE <b-final-predicate>
       )
       ```

     - Parameter concatenation in alias order; guard invalid scopes (e.g., where() applied after terminal compare).

   - Tests:

     - Convert the current xfail to pass (your `test_mid_chain_filter_on_nested_array`).
     - Add mixed AND/OR at alias and final levels; parentheses sanity tests.

2. **Micro-bench harness**

   - Keep under `tests/perf/bench_compare.py` (skipped unless `--perf`).
   - Compare:

     - naive LIKE vs `json_each` membership on arrays of primitives.
     - impact of `ensure_index("<path>")` for filter + order + limit.

   - Produce median/ops numbers to paste into README briefly.

3. **Docs**

   - Add a short “Scoped `any().where(...)`” example to README + cookbook.
   - Note the caveats and JSON1 dependence.

> That’s it. From my POV, you’re already at MVP and ready to publish. M8 is a nice polish, not a blocker.
